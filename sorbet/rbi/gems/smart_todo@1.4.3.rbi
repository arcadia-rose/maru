# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `smart_todo` gem.
# Please instead update this file by running `bin/tapioca gem smart_todo`.

# source://smart_todo//lib/smart_todo/version.rb#3
module SmartTodo; end

# This class is the entrypoint of the SmartTodo library and is responsible
# to retrieve the command line options as well as iterating over each files/directories
# to run the +CommentParser+ on.
#
# source://smart_todo//lib/smart_todo/cli.rb#9
class SmartTodo::CLI
  # @return [CLI] a new instance of CLI
  #
  # source://smart_todo//lib/smart_todo/cli.rb#10
  def initialize; end

  # @return [OptionParser] an instance of OptionParser
  #
  # source://smart_todo//lib/smart_todo/cli.rb#38
  def define_options; end

  # @return [Class] a Dispatchers::Base subclass
  #
  # source://smart_todo//lib/smart_todo/cli.rb#54
  def dispatcher; end

  # @param path [String] a path to a file or directory
  # @return [Array<String>] all the directories the parser should run on
  #
  # source://smart_todo//lib/smart_todo/cli.rb#60
  def normalize_path(path); end

  # @param file [String] a path to a file
  #
  # source://smart_todo//lib/smart_todo/cli.rb#69
  def parse_file(file); end

  # @param args [Array<String>]
  #
  # source://smart_todo//lib/smart_todo/cli.rb#15
  def run(args = T.unsafe(nil)); end

  # @raise [ArgumentError] In case an option needed by a dispatcher wasn't provided.
  # @return [void]
  #
  # source://smart_todo//lib/smart_todo/cli.rb#33
  def validate_options!; end
end

# source://smart_todo//lib/smart_todo.rb#23
module SmartTodo::Dispatchers; end

# source://smart_todo//lib/smart_todo/dispatchers/base.rb#5
class SmartTodo::Dispatchers::Base
  # @param event_message [String] the success message associated
  #   a specific event
  # @param todo_node [SmartTodo::Parser::TodoNode]
  # @param file [String] the file containing the TODO
  # @param options [Hash]
  # @return [Base] a new instance of Base
  #
  # source://smart_todo//lib/smart_todo/dispatchers/base.rb#36
  def initialize(event_message, todo_node, file, options); end

  # This method gets called when a TODO reminder is expired and needs to be delivered.
  # Dispatchers should implement this method to deliver the message where they need.
  #
  # @raise [NotImplemetedError]
  # @return void
  #
  # source://smart_todo//lib/smart_todo/dispatchers/base.rb#48
  def dispatch; end

  private

  # Hello message for user actually existing in the organization
  #
  # source://smart_todo//lib/smart_todo/dispatchers/base.rb#89
  def existing_user; end

  # Prepare the content of the message to send to the TODO assignee
  #
  # @param user [Hash] contain information about a user
  # @param assignee [String] original string handle the slack message should be sent
  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/dispatchers/base.rb#59
  def slack_message(user, assignee); end

  # Message in case a TODO's assignee doesn't exist in the Slack organization
  #
  # @param user [Hash]
  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/dispatchers/base.rb#84
  def unexisting_user(assignee); end

  class << self
    # Factory pattern to retrive the right dispatcher class.
    #
    # @param dispatcher [String]
    # @return [Class]
    #
    # source://smart_todo//lib/smart_todo/dispatchers/base.rb#11
    def class_for(dispatcher); end

    # Subclasses should define what options from the CLI they need in order
    # to properly deliver the message. For instance the Slack dispatcher
    # requires an API key.
    #
    # @param _options [Hash]
    # @raise [NotImplemetedError]
    # @return void
    #
    # source://smart_todo//lib/smart_todo/dispatchers/base.rb#27
    def validate_options!(_options); end
  end
end

# A simple dispatcher that will output the reminder.
#
# source://smart_todo//lib/smart_todo/dispatchers/output.rb#6
class SmartTodo::Dispatchers::Output < ::SmartTodo::Dispatchers::Base
  # @return void
  #
  # source://smart_todo//lib/smart_todo/dispatchers/output.rb#10
  def dispatch; end

  class << self
    # source://smart_todo//lib/smart_todo/dispatchers/output.rb#7
    def validate_options!(_); end
  end
end

# Dispatcher that sends TODO reminders on Slack. Assignees can be either individual
# (using the associated slack email address) or a channel.
#
# source://smart_todo//lib/smart_todo/dispatchers/slack.rb#7
class SmartTodo::Dispatchers::Slack < ::SmartTodo::Dispatchers::Base
  # Make a Slack API call to dispatch the message to each assignee
  #
  # @raise [SlackClient::Error] in case the Slack API returns an error
  #   other than `users_not_found`
  # @return [Array] Slack response for each assignee a message was sent to
  #
  # source://smart_todo//lib/smart_todo/dispatchers/slack.rb#20
  def dispatch; end

  # Make a Slack API call to dispatch the message to the user or channel
  #
  # @param the [String] assignee handle string
  # @raise [SlackClient::Error] in case the Slack API returns an error
  #   other than `users_not_found`
  # @return [Hash] the Slack response
  #
  # source://smart_todo//lib/smart_todo/dispatchers/slack.rb#33
  def dispatch_one(assignee); end

  private

  # @return [SlackClient] an instance of SlackClient
  #
  # source://smart_todo//lib/smart_todo/dispatchers/slack.rb#62
  def client; end

  # Returns a formatted hash containing either the user id of a slack user or
  # the channel the message should be sent to.
  #
  # @return [Hash] a suited hash containing the user ID for a given individual or a slack channel
  #
  # source://smart_todo//lib/smart_todo/dispatchers/slack.rb#53
  def slack_user_or_channel(assignee); end

  class << self
    # source://smart_todo//lib/smart_todo/dispatchers/slack.rb#8
    def validate_options!(options); end
  end
end

# This module contains all the methods accessible for SmartTodo comments.
# It is meant to be reopened by the host application in order to define
# its own events.
#
# An event needs to return a +String+ containing the message that will be
# sent to the TODO assignee or +false+ in case the event hasn't been met.
#
# @example Adding a custom event
#   module SmartTodo
#   module Events
#   def trello_card_close(card)
#   ...
#   end
#   end
#   end
#
#   TODO(on: trello_card_close(381), to: 'john@example.com')
#
# source://smart_todo//lib/smart_todo/events.rb#21
module SmartTodo::Events
  extend ::SmartTodo::Events

  # Check if the +date+ is in the past
  #
  # @param date [String] a correctly formatted date
  # @return [false, String]
  #
  # source://smart_todo//lib/smart_todo/events.rb#28
  def date(date); end

  # Check if +gem_name+ was bumped to the +requirements+ expected
  #
  # @param gem_name [String]
  # @param requirements [Array<String>] a list of version specifiers
  # @return [false, String]
  #
  # source://smart_todo//lib/smart_todo/events.rb#46
  def gem_bump(gem_name, *requirements); end

  # Check if a new version of +gem_name+ was released with the +requirements+ expected
  #
  # @param gem_name [String]
  # @param requirements [Array<String>] a list of version specifiers
  # @return [false, String]
  #
  # source://smart_todo//lib/smart_todo/events.rb#37
  def gem_release(gem_name, *requirements); end

  # Check if the issue +issue_number+ is closed
  #
  # @param organization [String] the GitHub organization name
  # @param repo [String] the GitHub repo name
  # @param issue_number [String, Integer]
  # @return [false, String]
  #
  # source://smart_todo//lib/smart_todo/events.rb#56
  def issue_close(organization, repo, issue_number); end

  # Check if the pull request +pr_number+ is closed
  #
  # @param organization [String] the GitHub organization name
  # @param repo [String] the GitHub repo name
  # @param pr_number [String, Integer]
  # @return [false, String]
  #
  # source://smart_todo//lib/smart_todo/events.rb#66
  def pull_request_close(organization, repo, pr_number); end
end

# An event that check if the passed date is passed
#
# source://smart_todo//lib/smart_todo/events/date.rb#8
class SmartTodo::Events::Date
  class << self
    # @param on_date [String]
    # @return [String]
    #
    # source://smart_todo//lib/smart_todo/events/date.rb#21
    def message(on_date); end

    # @param on_date [String] a string parsable by Time.parse
    # @return [String, false]
    #
    # source://smart_todo//lib/smart_todo/events/date.rb#11
    def met?(on_date); end
  end
end

# An event that compare the version of a gem specified in your Gemfile.lock
# with the expected version specifiers.
#
# source://smart_todo//lib/smart_todo/events/gem_bump.rb#10
class SmartTodo::Events::GemBump
  # @example Expecting a specific version
  #   GemBump.new('rails', ['6.0'])
  # @example Expecting a version in the 5.x.x series
  #   GemBump.new('rails', ['> 5.2', '< 6'])
  # @param gem_name [String]
  # @param requirements [Array] a list of version specifiers.
  #   The specifiers are the same as the one used in Gemfiles or Gemspecs
  # @return [GemBump] a new instance of GemBump
  #
  # source://smart_todo//lib/smart_todo/events/gem_bump.rb#20
  def initialize(gem_name, requirements); end

  # Error message send to Slack in case a gem couldn't be found
  #
  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/events/gem_bump.rb#40
  def error_message; end

  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/events/gem_bump.rb#45
  def message(version_number); end

  # @return [String, false]
  #
  # source://smart_todo//lib/smart_todo/events/gem_bump.rb#26
  def met?; end

  private

  # @return [Bundler::SpecSet] an instance of Bundler::SpecSet
  #
  # source://smart_todo//lib/smart_todo/events/gem_bump.rb#52
  def spec_set; end
end

# An event that check if a new version of gem has been released on RubyGem
# with the expected version specifiers.
# This event will make an API call to the RubyGem API
#
# source://smart_todo//lib/smart_todo/events/gem_release.rb#11
class SmartTodo::Events::GemRelease
  # @example Expecting a specific version
  #   GemRelease.new('rails', ['6.0'])
  # @example Expecting a version in the 5.x.x series
  #   GemRelease.new('rails', ['> 5.2', '< 6'])
  # @param gem_name [String]
  # @param requirements [Array] a list of version specifiers.
  #   The specifiers are the same as the one used in Gemfiles or Gemspecs
  # @return [GemRelease] a new instance of GemRelease
  #
  # source://smart_todo//lib/smart_todo/events/gem_release.rb#21
  def initialize(gem_name, requirements); end

  # Error message send to Slack in case a gem couldn't be found
  #
  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/events/gem_release.rb#42
  def error_message; end

  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/events/gem_release.rb#47
  def message(version_number); end

  # @return [String, false]
  #
  # source://smart_todo//lib/smart_todo/events/gem_release.rb#27
  def met?; end

  private

  # @return [Net::HTTP] an instance of Net::HTTP
  #
  # source://smart_todo//lib/smart_todo/events/gem_release.rb#62
  def client; end

  # @param gem_versions [String] the response sent from RubyGems
  # @return [true, false]
  #
  # source://smart_todo//lib/smart_todo/events/gem_release.rb#55
  def version_released?(gem_versions); end
end

# An event that check if a GitHub Pull Request or Issue is closed.
# This event will make an API call to the GitHub API.
#
# If the Pull Request or Issue is on a private repository, exporting a token
# with the `repos` scope in the +SMART_TODO_GITHUB_TOKEN+ environment variable
# is required.
#
# source://smart_todo//lib/smart_todo/events/issue_close.rb#14
class SmartTodo::Events::IssueClose
  # @param organization [String]
  # @param repo [String]
  # @param pr_number [String, Integer]
  # @return [IssueClose] a new instance of IssueClose
  #
  # source://smart_todo//lib/smart_todo/events/issue_close.rb#20
  def initialize(organization, repo, pr_number, type:); end

  # Error message send to Slack in case the Pull Request or Issue couldn't be found.
  #
  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/events/issue_close.rb#43
  def error_message; end

  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/events/issue_close.rb#54
  def message; end

  # @return [String, false]
  #
  # source://smart_todo//lib/smart_todo/events/issue_close.rb#28
  def met?; end

  private

  # @return [Net::HTTP] an instance of Net::HTTP
  #
  # source://smart_todo//lib/smart_todo/events/issue_close.rb#64
  def client; end

  # @return [Hash]
  #
  # source://smart_todo//lib/smart_todo/events/issue_close.rb#79
  def default_headers; end

  # @param pull_request [String] the Pull Request or Issue
  #   detail sent back from the GitHub API
  # @return [true, false]
  #
  # source://smart_todo//lib/smart_todo/events/issue_close.rb#74
  def pull_request_closed?(pull_request); end
end

# source://smart_todo//lib/smart_todo/events/issue_close.rb#15
SmartTodo::Events::IssueClose::TOKEN_ENV = T.let(T.unsafe(nil), String)

# source://smart_todo//lib/smart_todo.rb#10
module SmartTodo::Parser; end

# This class is used to parse Ruby code and will stop each time
# a Ruby comment is encountered. It will detect if a TODO comment
# is a Smart Todo and will gather the comments associated to the TODO.
#
# source://smart_todo//lib/smart_todo/parser/comment_parser.rb#10
class SmartTodo::Parser::CommentParser < ::Ripper::Filter
  # @return [CommentParser] a new instance of CommentParser
  #
  # source://smart_todo//lib/smart_todo/parser/comment_parser.rb#11
  def initialize(*_arg0); end

  # @param comment [String] the actual Ruby comment
  # @param data [Array<TodoNode>]
  # @return [Array<TodoNode>]
  #
  # source://smart_todo//lib/smart_todo/parser/comment_parser.rb#19
  def on_comment(comment, data); end

  # @param init [Array]
  # @return [Array<TodoNode>]
  #
  # source://smart_todo//lib/smart_todo/parser/comment_parser.rb#35
  def parse(init = T.unsafe(nil)); end

  private

  # @param data [Array<TodoNode>]
  # @return [Array<TodoNode>]
  #
  # source://smart_todo//lib/smart_todo/parser/comment_parser.rb#66
  def append_existing_node(data); end

  # Check if the comment is associated with the Smart Todo
  #
  # @example When a comment is associated to a SmartTodo
  #   TODO(on_date(...), to: '...')
  #   This is an associated comment
  # @example When a comment is not associated to a SmartTodo
  #   TODO(on_date(...), to: '...')
  #   This is an associated comment (Note the indentation)
  # @param comment [String] the actual Ruby comment
  # @return [true, false]
  #
  # source://smart_todo//lib/smart_todo/parser/comment_parser.rb#60
  def todo_comment?(comment); end

  # @param comment [String] the actual Ruby comment
  # @return [nil, Integer]
  #
  # source://smart_todo//lib/smart_todo/parser/comment_parser.rb#45
  def todo_metadata?(comment); end
end

# This class is used to parse the ruby TODO() comment.
#
# source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#20
class SmartTodo::Parser::MetadataParser < ::Ripper
  # @param list [nil, Array]
  # @param arg [String]
  # @return [Array]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#48
  def on_args_add(list, arg); end

  # @param key [String]
  # @param value [String, Integer, MethodNode]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#60
  def on_assoc_new(key, value); end

  # @param data [Hash]
  # @return [Hash]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#75
  def on_bare_assoc_hash(data); end

  # @param method [String] the name of the method
  #   when the parser hits one.
  # @param args [Array]
  # @return [Array, MethodNode]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#37
  def on_method_add_arg(method, args); end

  # @return [Array] an Array of Array
  #   the first element from each inner array is a token
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#29
  def on_stmts_add(_, data); end

  # @param string_content [String]
  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#54
  def on_string_add(_, string_content); end

  class << self
    # @param source [String] the actual Ruby code
    #
    # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#22
    def parse(source); end
  end
end

# A MethodNode represent an event associated to a TODO.
#
# source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#8
class SmartTodo::Parser::MethodNode
  # @param method_name [Symbol]
  # @param arguments [Array<String>]
  # @return [MethodNode] a new instance of MethodNode
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#13
  def initialize(method_name, arguments); end

  # Returns the value of attribute arguments.
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#9
  def arguments; end

  # Returns the value of attribute method_name.
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#9
  def method_name; end
end

# Represents a SmartTodo which includes the associated events
# as well as the assignee.
#
# source://smart_todo//lib/smart_todo/parser/todo_node.rb#7
class SmartTodo::Parser::TodoNode
  # @param todo [String] the actual Ruby comment
  # @return [TodoNode] a new instance of TodoNode
  #
  # source://smart_todo//lib/smart_todo/parser/todo_node.rb#13
  def initialize(todo); end

  # @param comment [String]
  # @return [void]
  #
  # source://smart_todo//lib/smart_todo/parser/todo_node.rb#28
  def <<(comment); end

  # Return the associated comment for this TODO
  #
  # @return [String]
  #
  # source://smart_todo//lib/smart_todo/parser/todo_node.rb#22
  def comment; end

  # Check if the +comment+ is indented two spaces below the
  # TODO declaration. If yes the comment is considered to be part
  # of the TODO itself. Otherwise it's just a regular comment.
  #
  # @param comment [String]
  # @return [true, false]
  #
  # source://smart_todo//lib/smart_todo/parser/todo_node.rb#38
  def indented_comment?(comment); end

  # Returns the value of attribute metadata.
  #
  # source://smart_todo//lib/smart_todo/parser/todo_node.rb#10
  def metadata; end
end

# source://smart_todo//lib/smart_todo/parser/todo_node.rb#8
SmartTodo::Parser::TodoNode::DEFAULT_RUBY_INDENTATION = T.let(T.unsafe(nil), Integer)

# source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#80
class SmartTodo::Parser::Visitor
  # @return [Visitor] a new instance of Visitor
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#83
  def initialize; end

  # Returns the value of attribute assignees.
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#81
  def assignees; end

  # Returns the value of attribute events.
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#81
  def events; end

  # @param assignee [String]
  # @return [void]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#114
  def on_todo_assignee(assignee); end

  # @param method_node [MethodNode]
  # @return [void]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#106
  def on_todo_event(method_node); end

  # Iterate over each tokens returned from the parser and call
  # the corresponding method
  #
  # @param sexp [Array]
  # @return [void]
  #
  # source://smart_todo//lib/smart_todo/parser/metadata_parser.rb#93
  def process(sexp); end
end

# A simple client around the Slack API.
#
# @example Sending a message to a user.
#   SmartTodo::SlackClient.new.post_message('#general', 'Hello!')
#
# source://smart_todo//lib/smart_todo/slack_client.rb#12
class SmartTodo::SlackClient
  # @param slack_token [String]
  # @return [SlackClient] a new instance of SlackClient
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#27
  def initialize(slack_token); end

  # Retrieve the Slack ID of a user from his email
  #
  # @param email [String]
  # @raise [Net::HTTPError] in case the request to Slack failed
  # @raise [SlackClient::Error] in case Slack returns a { ok: false } in the body
  # @return [Hash]
  # @see https://api.slack.com/methods/users.lookupByEmail
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#45
  def lookup_user_by_email(email); end

  # Send a message to a Slack channel or to a user
  #
  # @param channel [String] The Slack channel or the user ID
  # @param text [String] The message to send
  # @raise [Net::HTTPError] in case the request to Slack failed
  # @raise [SlackClient::Error] in case Slack returns a { ok: false } in the body
  # @return [Hash]
  # @see https://api.slack.com/methods/chat.postMessage
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#61
  def post_message(channel, text); end

  private

  # The default headers required by Slack
  #
  # @return [Hash]
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#107
  def default_headers; end

  # @param method [Symbol]
  # @param endpoint [String]
  # @param data [String] JSON encoded data when making a POST request
  # @param headers [Hash]
  # @raise [Net::HTTPError] in case the request to Slack failed
  # @raise [SlackClient::Error] in case Slack returns a { ok: false } in the body
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#74
  def request(method, endpoint, data = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Chech if the response to Slack was a 200 and the Slack API request was successful
  #
  # @param response [Net::HTTPResponse] a net Net::HTTPResponse subclass
  #   (Net::HTTPOK, Net::HTTPNotFound ...)
  # @raise [Net::HTTPError] in case the request to Slack failed
  # @raise [SlackClient::Error] in case Slack returns a { ok: false } in the body
  # @return [Hash]
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#93
  def slack_response!(response); end
end

# A generic error class raised when the Slack API returns back a 200
# but there was a problem (permission issues ...)
#
# source://smart_todo//lib/smart_todo/slack_client.rb#15
class SmartTodo::SlackClient::Error < ::StandardError
  # @param response_body [Hash] the parsed response body from Slack
  # @return [Error] a new instance of Error
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#19
  def initialize(response_body); end

  # Returns the value of attribute error_code.
  #
  # source://smart_todo//lib/smart_todo/slack_client.rb#16
  def error_code; end
end

# source://smart_todo//lib/smart_todo/version.rb#4
SmartTodo::VERSION = T.let(T.unsafe(nil), String)
